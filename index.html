<!DOCTYPE html><html>

<head>
<meta charset="utf-8">
<title>README</title>
<style type="text/css">
body {
  font-family: Helvetica, arial, sans-serif;
  font-size: 14px;
  line-height: 1.6;
  padding-top: 10px;
  padding-bottom: 10px;
  background-color: white;
  padding: 30px; }

body > *:first-child {
  margin-top: 0 !important; }
body > *:last-child {
  margin-bottom: 0 !important; }

a {
  color: #4183C4; }
a.absent {
  color: #cc0000; }
a.anchor {
  display: block;
  padding-left: 30px;
  margin-left: -30px;
  cursor: pointer;
  position: absolute;
  top: 0;
  left: 0;
  bottom: 0; }

h1, h2, h3, h4, h5, h6 {
  margin: 20px 0 10px;
  padding: 0;
  font-weight: bold;
  -webkit-font-smoothing: antialiased;
  cursor: text;
  position: relative; }

h1:hover a.anchor, h2:hover a.anchor, h3:hover a.anchor, h4:hover a.anchor, h5:hover a.anchor, h6:hover a.anchor {
  background: url(data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAYAAAAf8/9hAAAAGXRFWHRTb2Z0d2FyZQBBZG9iZSBJbWFnZVJlYWR5ccllPAAAA09pVFh0WE1MOmNvbS5hZG9iZS54bXAAAAAAADw/eHBhY2tldCBiZWdpbj0i77u/IiBpZD0iVzVNME1wQ2VoaUh6cmVTek5UY3prYzlkIj8+IDx4OnhtcG1ldGEgeG1sbnM6eD0iYWRvYmU6bnM6bWV0YS8iIHg6eG1wdGs9IkFkb2JlIFhNUCBDb3JlIDUuMy1jMDExIDY2LjE0NTY2MSwgMjAxMi8wMi8wNi0xNDo1NjoyNyAgICAgICAgIj4gPHJkZjpSREYgeG1sbnM6cmRmPSJodHRwOi8vd3d3LnczLm9yZy8xOTk5LzAyLzIyLXJkZi1zeW50YXgtbnMjIj4gPHJkZjpEZXNjcmlwdGlvbiByZGY6YWJvdXQ9IiIgeG1sbnM6eG1wPSJodHRwOi8vbnMuYWRvYmUuY29tL3hhcC8xLjAvIiB4bWxuczp4bXBNTT0iaHR0cDovL25zLmFkb2JlLmNvbS94YXAvMS4wL21tLyIgeG1sbnM6c3RSZWY9Imh0dHA6Ly9ucy5hZG9iZS5jb20veGFwLzEuMC9zVHlwZS9SZXNvdXJjZVJlZiMiIHhtcDpDcmVhdG9yVG9vbD0iQWRvYmUgUGhvdG9zaG9wIENTNiAoMTMuMCAyMDEyMDMwNS5tLjQxNSAyMDEyLzAzLzA1OjIxOjAwOjAwKSAgKE1hY2ludG9zaCkiIHhtcE1NOkluc3RhbmNlSUQ9InhtcC5paWQ6OUM2NjlDQjI4ODBGMTFFMTg1ODlEODNERDJBRjUwQTQiIHhtcE1NOkRvY3VtZW50SUQ9InhtcC5kaWQ6OUM2NjlDQjM4ODBGMTFFMTg1ODlEODNERDJBRjUwQTQiPiA8eG1wTU06RGVyaXZlZEZyb20gc3RSZWY6aW5zdGFuY2VJRD0ieG1wLmlpZDo5QzY2OUNCMDg4MEYxMUUxODU4OUQ4M0REMkFGNTBBNCIgc3RSZWY6ZG9jdW1lbnRJRD0ieG1wLmRpZDo5QzY2OUNCMTg4MEYxMUUxODU4OUQ4M0REMkFGNTBBNCIvPiA8L3JkZjpEZXNjcmlwdGlvbj4gPC9yZGY6UkRGPiA8L3g6eG1wbWV0YT4gPD94cGFja2V0IGVuZD0iciI/PsQhXeAAAABfSURBVHjaYvz//z8DJYCRUgMYQAbAMBQIAvEqkBQWXI6sHqwHiwG70TTBxGaiWwjCTGgOUgJiF1J8wMRAIUA34B4Q76HUBelAfJYSA0CuMIEaRP8wGIkGMA54bgQIMACAmkXJi0hKJQAAAABJRU5ErkJggg==) no-repeat 10px center;
  text-decoration: none; }

h1 tt, h1 code {
  font-size: inherit; }

h2 tt, h2 code {
  font-size: inherit; }

h3 tt, h3 code {
  font-size: inherit; }

h4 tt, h4 code {
  font-size: inherit; }

h5 tt, h5 code {
  font-size: inherit; }

h6 tt, h6 code {
  font-size: inherit; }

h1 {
  font-size: 28px;
  color: black; }

h2 {
  font-size: 24px;
  border-bottom: 1px solid #cccccc;
  color: black; }

h3 {
  font-size: 18px; }

h4 {
  font-size: 16px; }

h5 {
  font-size: 14px; }

h6 {
  color: #777777;
  font-size: 14px; }

p, blockquote, ul, ol, dl, li, table, pre {
  margin: 15px 0; }

hr {
  background: transparent url(data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAYAAAAECAYAAACtBE5DAAAAGXRFWHRTb2Z0d2FyZQBBZG9iZSBJbWFnZVJlYWR5ccllPAAAAyJpVFh0WE1MOmNvbS5hZG9iZS54bXAAAAAAADw/eHBhY2tldCBiZWdpbj0i77u/IiBpZD0iVzVNME1wQ2VoaUh6cmVTek5UY3prYzlkIj8+IDx4OnhtcG1ldGEgeG1sbnM6eD0iYWRvYmU6bnM6bWV0YS8iIHg6eG1wdGs9IkFkb2JlIFhNUCBDb3JlIDUuMC1jMDYwIDYxLjEzNDc3NywgMjAxMC8wMi8xMi0xNzozMjowMCAgICAgICAgIj4gPHJkZjpSREYgeG1sbnM6cmRmPSJodHRwOi8vd3d3LnczLm9yZy8xOTk5LzAyLzIyLXJkZi1zeW50YXgtbnMjIj4gPHJkZjpEZXNjcmlwdGlvbiByZGY6YWJvdXQ9IiIgeG1sbnM6eG1wPSJodHRwOi8vbnMuYWRvYmUuY29tL3hhcC8xLjAvIiB4bWxuczp4bXBNTT0iaHR0cDovL25zLmFkb2JlLmNvbS94YXAvMS4wL21tLyIgeG1sbnM6c3RSZWY9Imh0dHA6Ly9ucy5hZG9iZS5jb20veGFwLzEuMC9zVHlwZS9SZXNvdXJjZVJlZiMiIHhtcDpDcmVhdG9yVG9vbD0iQWRvYmUgUGhvdG9zaG9wIENTNSBNYWNpbnRvc2giIHhtcE1NOkluc3RhbmNlSUQ9InhtcC5paWQ6OENDRjNBN0E2NTZBMTFFMEI3QjRBODM4NzJDMjlGNDgiIHhtcE1NOkRvY3VtZW50SUQ9InhtcC5kaWQ6OENDRjNBN0I2NTZBMTFFMEI3QjRBODM4NzJDMjlGNDgiPiA8eG1wTU06RGVyaXZlZEZyb20gc3RSZWY6aW5zdGFuY2VJRD0ieG1wLmlpZDo4Q0NGM0E3ODY1NkExMUUwQjdCNEE4Mzg3MkMyOUY0OCIgc3RSZWY6ZG9jdW1lbnRJRD0ieG1wLmRpZDo4Q0NGM0E3OTY1NkExMUUwQjdCNEE4Mzg3MkMyOUY0OCIvPiA8L3JkZjpEZXNjcmlwdGlvbj4gPC9yZGY6UkRGPiA8L3g6eG1wbWV0YT4gPD94cGFja2V0IGVuZD0iciI/PqqezsUAAAAfSURBVHjaYmRABcYwBiM2QSA4y4hNEKYDQxAEAAIMAHNGAzhkPOlYAAAAAElFTkSuQmCC) repeat-x 0 0;
  border: 0 none;
  color: #cccccc;
  height: 4px;
  padding: 0;
}

body > h2:first-child {
  margin-top: 0;
  padding-top: 0; }
body > h1:first-child {
  margin-top: 0;
  padding-top: 0; }
  body > h1:first-child + h2 {
    margin-top: 0;
    padding-top: 0; }
body > h3:first-child, body > h4:first-child, body > h5:first-child, body > h6:first-child {
  margin-top: 0;
  padding-top: 0; }

a:first-child h1, a:first-child h2, a:first-child h3, a:first-child h4, a:first-child h5, a:first-child h6 {
  margin-top: 0;
  padding-top: 0; }

h1 p, h2 p, h3 p, h4 p, h5 p, h6 p {
  margin-top: 0; }

li p.first {
  display: inline-block; }
li {
  margin: 0; }
ul, ol {
  padding-left: 30px; }

ul :first-child, ol :first-child {
  margin-top: 0; }

dl {
  padding: 0; }
  dl dt {
    font-size: 14px;
    font-weight: bold;
    font-style: italic;
    padding: 0;
    margin: 15px 0 5px; }
    dl dt:first-child {
      padding: 0; }
    dl dt > :first-child {
      margin-top: 0; }
    dl dt > :last-child {
      margin-bottom: 0; }
  dl dd {
    margin: 0 0 15px;
    padding: 0 15px; }
    dl dd > :first-child {
      margin-top: 0; }
    dl dd > :last-child {
      margin-bottom: 0; }

blockquote {
  border-left: 4px solid #dddddd;
  padding: 0 15px;
  color: #777777; }
  blockquote > :first-child {
    margin-top: 0; }
  blockquote > :last-child {
    margin-bottom: 0; }

table {
  padding: 0;border-collapse: collapse; }
  table tr {
    border-top: 1px solid #cccccc;
    background-color: white;
    margin: 0;
    padding: 0; }
    table tr:nth-child(2n) {
      background-color: #f8f8f8; }
    table tr th {
      font-weight: bold;
      border: 1px solid #cccccc;
      margin: 0;
      padding: 6px 13px; }
    table tr td {
      border: 1px solid #cccccc;
      margin: 0;
      padding: 6px 13px; }
    table tr th :first-child, table tr td :first-child {
      margin-top: 0; }
    table tr th :last-child, table tr td :last-child {
      margin-bottom: 0; }

img {
  max-width: 100%; }

span.frame {
  display: block;
  overflow: hidden; }
  span.frame > span {
    border: 1px solid #dddddd;
    display: block;
    float: left;
    overflow: hidden;
    margin: 13px 0 0;
    padding: 7px;
    width: auto; }
  span.frame span img {
    display: block;
    float: left; }
  span.frame span span {
    clear: both;
    color: #333333;
    display: block;
    padding: 5px 0 0; }
span.align-center {
  display: block;
  overflow: hidden;
  clear: both; }
  span.align-center > span {
    display: block;
    overflow: hidden;
    margin: 13px auto 0;
    text-align: center; }
  span.align-center span img {
    margin: 0 auto;
    text-align: center; }
span.align-right {
  display: block;
  overflow: hidden;
  clear: both; }
  span.align-right > span {
    display: block;
    overflow: hidden;
    margin: 13px 0 0;
    text-align: right; }
  span.align-right span img {
    margin: 0;
    text-align: right; }
span.float-left {
  display: block;
  margin-right: 13px;
  overflow: hidden;
  float: left; }
  span.float-left span {
    margin: 13px 0 0; }
span.float-right {
  display: block;
  margin-left: 13px;
  overflow: hidden;
  float: right; }
  span.float-right > span {
    display: block;
    overflow: hidden;
    margin: 13px auto 0;
    text-align: right; }

code, tt {
  margin: 0 2px;
  padding: 0 5px;
  white-space: nowrap;
  border: 1px solid #eaeaea;
  background-color: #f8f8f8;
  border-radius: 3px; }

pre code {
  margin: 0;
  padding: 0;
  white-space: pre;
  border: none;
  background: transparent; }

.highlight pre {
  background-color: #f8f8f8;
  border: 1px solid #cccccc;
  font-size: 13px;
  line-height: 19px;
  overflow: auto;
  padding: 6px 10px;
  border-radius: 3px; }

pre {
  background-color: #f8f8f8;
  border: 1px solid #cccccc;
  font-size: 13px;
  line-height: 19px;
  overflow: auto;
  padding: 6px 10px;
  border-radius: 3px; }
  pre code, pre tt {
    background-color: transparent;
    border: none; }

sup {
    font-size: 0.83em;
    vertical-align: super;
    line-height: 0;
}
* {
	-webkit-print-color-adjust: exact;
}
@media screen and (min-width: 914px) {
    body {
        width: 854px;
        margin:0 auto;
    }
}
@media print {
	table, pre {
		page-break-inside: avoid;
	}
	pre {
		word-wrap: break-word;
	}
}
</style>
</head>
<body>
<h1 id="toc_0">Grid Learning: Max</h1>

<p>Max is... (INSERT HERE)</p>

<p><a href="http://cycling74.com">cycling74.com</a></p>

<p>If you haven&#39;t yet run the Monome installer, do so first by going here:</p>

<p><a href="http://monome.org/docs/begin">monome.org/docs/begin</a></p>

<h2 id="toc_1">1. Connect</h2>

<p><em>See grid-learn-1-1.maxpat for this section.</em></p>

<p>To communicate with grids we trade OSC messages with serialosc. serialosc is translates OSC messages to streams of numbers over USB.</p>

<p>First we will show how to talk to serialosc.</p>

<p>Open Max and start a new patch.</p>

<p>Create a new object (press N) and type <code>bpatcher serialosc</code> and then hit enter. A bpatcher window will appear, resize this to match the long rectangle.</p>

<p><img src="images/grid-learn-1-1-1.png" alt=""></p>

<p>Plug in your grid and it will appear in the serialosc box. If you connect more than one grid, you can choose which device to communicate with via the dropdown.</p>

<p>Note: this box you&#39;ve imbedded isn&#39;t serialosc itself, which is an invisible daemon on your computer. This box is a helper patcher to simplify using serialosc. We&#39;ll refer to this helper as serialosc, hopefully without much confusion.</p>

<h2 id="toc_2">2. Basics</h2>

<p>Messages are sent to serialosc through the top left inlet, and received out the bottom left outlet.</p>

<p><em>See grid-learn-2-1.maxpat for this section.</em></p>

<h3 id="toc_3">2.1 Key input</h3>

<p>To see what is coming from the grid, create a <code>print</code> object and connect the left outlet of serialosc to it. Open the max console (Window -&gt; Max Console) and press some keys on the grid. OSC data will be displayed on the console.</p>

<p>Examining the output, key data fits this form:</p>

<pre><code>/monome/grid/key x y z</code></pre>

<p>Where x,y is the position and z indicates key down (1) or key up (0).</p>

<p>Other messages (such as connect and disconnect) come from this same outlet, so we want to filter for the key messages.</p>

<p>Change the <code>print</code> object to <code>route /monome/grid/key</code> and then see the output from the route.</p>

<p>We now have a list of 3 numbers according to each key action. Use an unpack to break this down further into individual numbers. Create a 16x8 matrixctrl object by typing:</p>

<pre><code>matrixctrl @columns 16 @rows 8</code></pre>

<p>Connect the output of the route to this <code>matrixctrl</code> for a graphical display of the grid&#39;s key state.</p>

<p><img src="images/grid-learn-2-1-1.png" alt=""></p>

<h3 id="toc_4">2.2 LED output</h3>

<p>Above the serialosc box create a message (push M) and type:</p>

<pre><code>/monome/grid/led/set 2 0 1</code></pre>

<p>Connect this to the left inlet of serialosc.</p>

<p>Clicking this box will light up LED 2 in row 0. The message format is:</p>

<pre><code>/monome/grid/led/set x y z</code></pre>

<p>This is similar to the key input message, where z is on (1) or off (0).</p>

<p>Using Max&#39;s list methods, use <code>$1 $2 $3</code> to change LEDs more dynamically. With a single message box as a sort of funnel, we can change various positions with message boxes, toggles, and a <code>matrixctrl</code>.</p>

<p>To clear the entire grid, use the following message:</p>

<pre><code>/monome/grid/led/all 0</code></pre>

<p><img src="images/grid-learn-2-2-1.png" alt=""></p>

<h3 id="toc_5">2.3 Coupled interaction</h3>

<p>Connect the output of</p>

<pre><code>route /max/grid/key</code></pre>

<p>to the <code>matrixctrl</code> which above serialosc which changes LEDs.</p>

<p>You now have a coupled interface, where the key state is reflected by the the LEDs.</p>

<p><img src="images/grid-learn-2-3-1.png" alt=""></p>

<h3 id="toc_6">2.4 Decoupled interaction</h3>

<p>The most fundamental decoupled interface is an array of toggles. We can accomplish this easily by ignoring the key up state, switching the LED state only on key down.</p>

<p>Remove the connection to the LED-driving <code>matrixctrl</code>. We can filter out key-up messages by re-arranging the order of the key output, using a route object:</p>

<pre><code>$3 $1 $2

route 1</code></pre>

<p>By moving the key state (z, here as <code>$3</code>) to the front, the route object will only pass messages where this first number is equal to 1. What comes out of route is just x and y. We can use this to toggle a matrixctrl by adding <code>inc</code> to the end of the message thusly:</p>

<pre><code>$1 $2 inc</code></pre>

<p>Connect this to the input of the <code>matrixctrl</code> and we have a toggle bank.</p>

<p><img src="images/grid-learn-2-4-1.png" alt=""></p>

<h2 id="toc_7">3.0 Further</h2>

<p>Now we&#39;ll show how basic grid applications are developed by creating a step sequencer. We will add features incrementally:</p>

<ul>
<li>Use the top six rows as toggles.</li>
<li>Accept a clock pulse to advance the playhead from left to right, one column at a time. Wrap back to 0 at the end.</li>
<li>Display the play head on &quot;position&quot; (last) row.</li>
<li>Indicate the &quot;activity&quot; row (second to last) with a low brightness.</li>
<li>Trigger an event when the playhead reads an &quot;on&quot; toggle. Our &quot;event&quot; will be to turn on the corresponding LED in the &quot;activity&quot; row.</li>
<li>Jump to playback position when key pressed in the position row.</li>
<li>Adjust playback loop with two-key gesture in position row.</li>
</ul>

<h3 id="toc_8">3.1 Toggles</h3>

<p><em>See grid-learn-3-1.maxpat for this step.</em></p>

<p>This works identically to our previous &quot;decoupled interaction&quot; example, but we want to only use the first six rows. So we sort them out inside the /p keys/ subpatcher:</p>

<pre><code>$2 $1 $3

route 6 7</code></pre>

<p>By switching the first and second elements and then putting them into the route object, rows 0-5 are passed to the right outlet. We&#39;ll then pass key-down messages only to the matrix toggling.</p>

<p><img src="images/grid-learn-3-1-1.png" alt=""></p>

<p><img src="images/grid-learn-3-1-2.png" alt=""></p>

<h3 id="toc_9">3.2 Play</h3>

<p><em>See grid-learn-3-2.maxpat for this step.</em></p>

<p>We can create a &quot;play head&quot; with a simple counter.</p>

<p><img src="images/grid-learn-3-2-1.png" alt=""></p>

<p>To see the play position on the bottom row, we will turn on the corresponding LED position after first clearing the entire row. We can clear a row by using a new OSC message:</p>

<pre><code>/monome/grid/led/row 0 7 0 0</code></pre>

<p>where the format of the message is:</p>

<pre><code>/monome/grid/led/row x_offset y d[...]</code></pre>

<p>Here y is 7, the last row. Check out the full OSC spec for more information on this message.</p>

<p>After we clear the row, we turn on the corresponding LED with a normal single-LED message:</p>

<pre><code>/monome/grid/led/set $1 0 1</code></pre>

<p>Now when you turn on the clock, you&#39;ll see the playhead moving along the bottom row.</p>

<h3 id="toc_10">3.3 Triggers</h3>

<p><em>See grid-learn-3-3.maxpat for this step.</em></p>

<p>As the playhead moves we will read the contents of the corresponding column and trigger events based on which toggles are turned on.</p>

<p>We do this by connecting a <code>getcolumn $1</code> to the toggle matrix, driven by the play position. The matrix will output a list of 0/1 values which indicate the toggle states from top to bottom. We can &quot;extract&quot; only the 1&#39;s (on-states) using a <code>zl sub 1</code> object. However, these values are index from 1, and we need them index from 0 (because this is how the grid indexes its LEDs) so we subtract one.</p>

<p>To indicate an &quot;event&quot; we will light up the corresponding x position in the 6th row:</p>

<pre><code>/monome/grid/led/set $1 6 1</code></pre>

<p><img src="images/grid-learn-3-3-1.png" alt=""></p>

<p>Similarly to the play position display, we need to clear the row between refreshes. But since more than one event can be displayed per step, we&#39;ll want to clear only once per group of triggers. We can accomplish the desired visual effect by clearing the row a delayed time after the events arrive.</p>

<p>Furthermore, to give the interface some delineation (not just a field of random LEDs) we will &quot;clear&quot; this row to a low-brightness level rather than completely off:</p>

<pre><code>/monome/grid/led/level/row 0 6 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5</code></pre>

<p>This /level/ message is in the format:</p>

<pre><code>/monome/grid/led/level/row x_off y d[...]</code></pre>

<p>The format is similar to the monochromatic <code>row</code> message, but here <code>d[...]</code> is discrete LED values of 0-15. The message we&#39;re using has 16 of the number 5, which sets the entire 6th row to a dim level.</p>

<p>The &quot;triggered&quot; LEDs will be full brightness on top of this dim row.</p>

<p>Lastly, there&#39;s a tiny sound engine so you can actually hear something. Turn on the DAC and turn up the gain slider. Change the note values by opening up the <code>p trigs</code> subpatcher.</p>

<h3 id="toc_11">3.4 Cutting and Looping</h3>

<p><em>See grid-learn-3-4.maxpat for this step.</em></p>

<p>To liven up the sequencer, we will have key presses on the play row jump to the pressed position. But we also want a two-key gesture (holding down a first while pressing a second) to set the start-end loop boundaries. This requires keeping track of how many keys are being held down in the last row.</p>

<p>First we add the <code>r counter</code> receive object above the counter. Then the rest of the patching happens inside the <code>p key</code> subpatcher.</p>

<p><img src="images/grid-learn-3-4-1.png" alt=""></p>

<p>We unpack the incoming message and keep track of the accumulation of key ups and downs. This is accomplished by adding one for each key up and subtracting one for each key down. This looks weird as a Max patch, but tracing through it will reveal the logic.</p>

<p>The number of keys held will gate the output of the x position of the key. When a single key is pressed the x position goes out the left outlet of the gate, setting the position of the counter. This first position is also stored for potential use later.</p>

<p>If a second key is pressed (in this same row) while a first is held, the current x position pressed is set as the loop max (with a <code>/max $1/</code> message) and the previously pressed x position is recalled and set as the loop minimum (with a <code>/setmin $1/</code> message).</p>

<h2 id="toc_12">Closing</h2>

<p>We&#39;ve created a minimal yet intuitive interface for rapidly exploring sequences. We can intuitively change event triggers, loop points, and jump around the data performatively. Many more features could be added, and there are numerous other ways to think about interaction between key press and light feedback in completely different contexts.</p>

<h3 id="toc_13">Suggested exercises</h3>

<ul>
<li>Display the loop range with dim LED levels.</li>
<li>&quot;Record&quot; keypresses in the &quot;trigger&quot; row to the toggle matrix.</li>
<li>Display the play head position as a dim column behind the toggle data.</li>
<li>Use the rightmost key in the &quot;trigger&quot; row as an &quot;alt&quot; key.

<ul>
<li>If &quot;alt&quot; is held while pressing a toggle, clear the entire row.</li>
<li>If &quot;alt&quot; is held while pressing the play row, reverse the direction of play.</li>
</ul></li>
</ul>

<h3 id="toc_14">Bonus</h3>

<p>See grid-learn-3-5.maxpat for a js implementation of this patch.</p>


</body>

</html>
